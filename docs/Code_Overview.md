This document provides information for developers interested in
understanding the code.

# Directory layout

- `fpga_src/`: The Verilog FPGA code.

- `src/`: Contains a Python host capture program (`hcap.py`) that can
  be used to extract data from the FPGA.

- `scripts/`: A collection of useful tools for building the FPGA code.

# FPGA code

Located in the `fpga_src/` directory and its sub-directories.

The `fpga_src/qbuild/` directory contains the Quartus project and
build rules.  The project can be manually imported into the Quartus
software using the `fpga_src/qbuild/Haasoscope.qpf` project file.

The top-level Verilog file for the project is `haasoscope.v`.  This
file is just a "glue" file connecting the wiring of the Verilog
modules.

There are several clocks used in the FPGA:
- The FPGA code has a primary clock running at 125Mhz.  This clock is
  generated by the FPGA PLL using the Haasoscope's 50Mhz external
  oscillator.
- A second 125Mhz clock is also generated by the PLL and routed to the
  second MAX19506 external ADC chip.  Normally this clock is
  synchronized to the main 125Mhz clock, but in "250Mhz interleaving
  mode" this clock is phase shifted by 4ns (so that samples from the
  two MAX19506 chips can be interleaved).
- The PLL also generates a 62.5Mhz clock (internally referred to as
  `slow_clk`).  This clock is needed for interacting with some MAX10
  FPGA hardware that can not operate at 125Mhz.  The clock is also
  used by some internal modules that do not require high speeds.
- When the optional ft232h (USB hi-speed module) is present it
  provides a 60Mhz clock to the FPGA.  The FPGA code uses that clock
  when interacting with that hardware.

## Major FPGA code components

There are several major components in the project code:

- Wishbone bus.  A
  [Wishbone](https://en.wikipedia.org/wiki/Wishbone_(computer_bus))
  bus is used as the main configuration system for the modules.
  Modules are given an "address range" that present a series of
  "registers".  The host code interacts with the FPGA by reading and
  programming these registers.  The `busdispatch.v`,
  `buslsdispatch.v`, and `cmdhandle/wbcmd.v` are key files in this
  component.

- Command interface.  The command interface reads messages from a
  "serial interface" (via the on-board full-speed USB adapter or
  optional hi-speed USB module) and translates them to Wishbone bus
  transactions.  See the [protocol document](Protocol.md) for details
  on the communication protocol.  The command interface also supports
  a "stream" mechanism for the FPGA to generate asynchronous messages
  for the host.  Code in the `cmdhandle/`, `uart/`, `ft232h/`, and
  `async_fifo/` sub-directories are used to implement the command
  interface.

- Samples queue.  The "samples queue" is an internal circular buffer
  used to store measurements.  It is implemented using the FPGA's
  internal memory.  Each "sample" in the "samples queue" is a 72-bit
  value containing data from a single source.  Since each ADC channel
  has 8-bits, a single 72bit entry is obtained by combining multiple
  measurements from that channel.  Data from the "samples queue" is
  forwarded to the host on a "trigger event".  The samples are sent
  using the command interface's message "stream" mechanism.  Code in
  the `sample/` sub-directory is used to implement the "samples
  queue".

- Additional component modules.  There are several additional modules
  to implement additional functionality.  In most cases these modules
  interact with the host software solely via the wishbone bus.

## Data flow of an ADC measurement

It can be helpful to understand how ADC data flows through the FPGA
modules.

- Data starts at the MAX19506 ADC chip and is read by the FPGA in the
  `maxadc/maxadcsync.v` code.  This module is primarily used to reduce
  the chance of meta-stability issues and to make the data available
  on the main 125Mhz FPGA clock.

- The data is then processed by the `sampleq/sampadcacc.v` module.
  This module accumulates multiple readings into a 72-bit "sample
  entry".

- Once a sample becomes available it is prioritized (by the
  `sampleq/sampselect.v` module) and read by the `sampleq/sampleq.v`
  module.  Samples are stored in a circular buffer implemented using
  the FPGA internal memory.

- Upon a "trigger" event (`sq_trigger`), the sampleq module will pull
  entries from the internal buffer and forward them as "stream
  messages" to the command handling code.  The
  `cmdhandle/streamselect.v` determines the current active stream and
  the `cmdhandle/msgencode.v` module generates the corresponding
  messages.

- The serial messages are sent to the host capture code either via the
  full-speed USB interface or the optional ft232h USB hi-speed
  interface.  The `cmdhandle/serialselect.v` module determines which
  interface is active (based upon which interface has last received a
  valid command).  For the on-board full-speed USB interface the
  message is processed by `uart/txuartlite.v`.  For the hi-speed
  interface, the `ft232h/ft232h.v` module is used.
